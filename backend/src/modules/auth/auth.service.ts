import {
  Injectable,
  BadRequestException,
  UnauthorizedException,
  InternalServerErrorException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { CookieOptions, Response } from 'express';
import {LoginDTO } from './dto/login.dto';
import { MailService } from 'src/common/services/mail.service';
import {RegisterUserDto} from './dto/register.dto';
import { Request } from 'express';
const ACCESS_EXPIRES_MS = 15 * 60 * 1000;         // 15m
const REFRESH_EXPIRES_MS = 7 * 24 * 60 * 60 * 1000; // 7d
@Injectable()
export class AuthService {
    constructor(
        private prisma: PrismaService,
        private jwtService: JwtService,
        private mailService: MailService,
        private configService: ConfigService,
    ) {}

    private cookieBase(): CookieOptions {
    const isProd = process.env.NODE_ENV === 'production';
    return {
      httpOnly: true,
      secure: isProd, // prod: true, dev: false
      sameSite: (isProd ? 'none' : 'lax') as CookieOptions['sameSite'],
      path: '/',
    };
}

  private signAccess(payload: any) {
  return this.jwtService.signAsync(payload, {
    secret: this.configService.get<string>('jwt.accessSecret'),
    expiresIn: this.configService.get<string>('jwt.accessExpiresIn'),
  });
}

private signRefresh(payload: any) {
  return this.jwtService.signAsync(payload, {
    secret: this.configService.get<string>('jwt.refreshSecret'),
    expiresIn: this.configService.get<string>('jwt.refreshExpiresIn'),
  });
}

// H√†m ƒëƒÉng nh·∫≠p
async login(dto: LoginDTO, res: Response) {
  const account = await this.prisma.account.findUnique({
    where: { email: dto.email },
  });
      if (!account) throw new UnauthorizedException('Invalid credentials');

      const ok = await bcrypt.compare(dto.password, account.password);
      if (!ok) throw new UnauthorizedException('Invalid email or password');
      if (account.status !== 'active') throw new UnauthorizedException('Account not active');

      const payload = { sub: account.id.toString(), role: account.role };

      const accessToken = await this.signAccess(payload);
      const refreshToken = await this.signRefresh(payload);

      // L∆∞u hash refresh token v√†o DB (stateful)
      const hashedRt = await bcrypt.hash(refreshToken, 10);
      await this.prisma.account.update({
        where: { id: account.id },
        data: { refreshToken: hashedRt },
      });

      // Set cookies
      res.cookie('access_token', accessToken, {
        ...this.cookieBase(),
        maxAge: ACCESS_EXPIRES_MS,
      });
      res.cookie('refresh_token', refreshToken, {
        ...this.cookieBase(),
        maxAge: REFRESH_EXPIRES_MS,
      });

      // Tr·∫£ k√®m th·ªùi gian h·∫øt h·∫°n access ƒë·ªÉ FE (n·∫øu th√≠ch) ƒë·∫∑t timer proactive
      return { message: 'Login successful', access_expires_in: 15 * 60 };
  }

  // Refresh + Rotate: n·∫øu h·ª£p l·ªá th√¨ c·∫•p M·ªöI c·∫£ access v√† refresh
  async refresh(req: Request, res: Response) {
    const rt = req.cookies?.['refresh_token'];
    if (!rt) throw new UnauthorizedException('No refresh token');

    let payload: any;
    try {
      payload = await this.jwtService.verifyAsync(rt, {
        secret: process.env.JWT_REFRESH_SECRET,
      });
    } catch {
      // H·∫øt h·∫°n ho·∫∑c sai ch·ªØ k√Ω
      res.clearCookie('access_token', this.cookieBase());
      res.clearCookie('refresh_token', this.cookieBase());
      throw new UnauthorizedException('Refresh token invalid/expired');
    }

    const accountId = BigInt(payload.sub);

    const account = await this.prisma.account.findUnique({
      where: { id: accountId },
    });
    if (!account || !account.refreshToken) throw new UnauthorizedException();

    // Kh·ªõp refresh token trong cookie v·ªõi hash trong DB
    const match = await bcrypt.compare(rt, account.refreshToken);
    if (!match) {
      // C√≥ th·ªÉ do b·ªã rotate tr∆∞·ªõc ƒë√≥ ho·∫∑c b·ªã ƒë√°nh c·∫Øp ‚Üí fail
      res.clearCookie('access_token', this.cookieBase());
      res.clearCookie('refresh_token', this.cookieBase());
      throw new UnauthorizedException('Refresh token mismatched');
    }

    // ‚úÖ ROTATE: c·∫•p token m·ªõi & c·∫≠p nh·∫≠t DB
    const newPayload = { sub: payload.sub, role: payload.role };
    const newAccess = await this.signAccess(newPayload);
    const newRefresh = await this.signRefresh(newPayload);
    const newHashedRt = await bcrypt.hash(newRefresh, 10);

    await this.prisma.account.update({
      where: { id: accountId },
      data: { refreshToken: newHashedRt },
    });

    res.cookie('access_token', newAccess, {
      ...this.cookieBase(),
      maxAge: ACCESS_EXPIRES_MS,
    });
    res.cookie('refresh_token', newRefresh, {
      ...this.cookieBase(),
      maxAge: REFRESH_EXPIRES_MS, // ‚¨ÖÔ∏è ‚Äúsliding‚Äù 7 ng√†y t√≠nh l·∫°i t·ª´ b√¢y gi·ªù
    });

    return { message: 'Token refreshed', access_expires_in: 15 * 60 };
  }

    // Register candidate
   async registerCandidate(dto: RegisterUserDto) {
    try {
        const exists = await this.prisma.account.findUnique({ where: { email: dto.email } });
        if (exists) throw new BadRequestException('Email already registered');

        const hashed = await bcrypt.hash(dto.password, 10);

        const account = await this.prisma.account.create({
        data: {
            email: dto.email,
            password: hashed,
            role: 'candidate',
            status: 'pending',
        },
        });

        const user = await this.prisma.user.create({
        data: {
            account_id: account.id,
            full_name: dto.fullName,
            phone: dto.phone,
            dob: dto.dob ? new Date(dto.dob) : undefined,
            gender: dto.gender,
            address: dto.address,
            avatar_url: dto.avatarUrl,
        },
        });

        await this.prisma.candidate.create({
        data: { user_id: user.id },
        });

        const token = await this.jwtService.signAsync(
        { sub: account.id.toString(), purpose: 'verify-email' },
        { expiresIn: '10m' },
        );
        const link = `http://localhost:3000/auth/verify-email?token=${token}`;
        await this.mailService.sendVerificationMail(account.email, link, user.full_name);
        return { message: 'Please check your email to verify account' };
    } catch (error) {
        console.error(error);
        throw error; // ho·∫∑c x·ª≠ l√Ω/log l·ªói t·∫°i ƒë√¢y n·∫øu mu·ªën
    }
}
    async registerRecruiter(dto: RegisterUserDto) {
    try {
        const exists = await this.prisma.account.findUnique({ where: { email: dto.email } });
        if (exists) throw new BadRequestException('Email already registered');

        const hashed = await bcrypt.hash(dto.password, 10);

        const account = await this.prisma.account.create({
        data: {
            email: dto.email,
            password: hashed,
            role: 'recruiter',
            status: 'pending',
        },
        });

        // T·∫°o user profile g·∫Øn v·ªõi account
        const user = await this.prisma.user.create({
        data: {
            account_id: account.id,
            full_name: dto.fullName,
            phone: dto.phone,
            dob: dto.dob ? new Date(dto.dob) : undefined,
            gender: dto.gender,
            address: dto.address,
            avatar_url: dto.avatarUrl,
        },
        });

        // T·∫°o token verify email
        const token = await this.jwtService.signAsync(
        { sub: account.id.toString(), purpose: 'verify-email' },
        { expiresIn: '15m' },
        );
        const link = `http://localhost:3000/auth/verify-email?token=${token}`;

        // G·ª≠i mail verify
        await this.mailService.sendVerificationMail(account.email, link, user.full_name);

        return { message: 'Please check your email to verify account' };
    } catch (error) {
        console.error(error);
        throw error;
    }
}

    // x√°c nh·∫≠n email:
    async verifyEmail(token: string) {
    try {
      const payload = await this.jwtService.verifyAsync(token);
      if (payload.purpose !== 'verify-email') {
        throw new BadRequestException('Invalid token purpose');
      }

      await this.prisma.account.update({
        where: { id: payload.sub },
        data: { status: 'active' },
      });

      return { message: 'Account verified successfully' };
    } catch (error) {
      console.error(error);
      throw new BadRequestException('Invalid or expired token');
    }
  }
    // G·ª≠i link qu√™n m·∫≠t kh·∫©u qua mail:
    async sendResetPasswordEmail(email: string) {
    try {
      const account = await this.prisma.account.findUnique({ where: { email } });

      if (account) {
        const token = await this.jwtService.signAsync(
          { sub: account.id.toString(), purpose: 'reset-password' },
          { expiresIn: '10m' },
        );

        const link = `${process.env.FRONTEND_URL}/reset-password?token=${token}`;
        console.log("üì© Reset password link:", link);

        await this.mailService.sendResetPasswordMail(email, link);
      }

      return { message: 'N·∫øu email t·ªìn t·∫°i, b·∫°n s·∫Ω nh·∫≠n ƒë∆∞·ª£c email reset m·∫≠t kh·∫©u' };
    } catch (err) {
      console.error("‚ùå L·ªói g·ª≠i mail:", err);
      throw new InternalServerErrorException("Kh√¥ng th·ªÉ g·ª≠i email, vui l√≤ng th·ª≠ l·∫°i sau");
    }
  }


    // H√†m ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u
    async resetPassword(token: string, newPassword: string) {
      try {
        const payload = await this.jwtService.verifyAsync(token);

        if (payload.purpose !== 'reset-password') {
          throw new BadRequestException('Invalid token purpose');
        }

        // ‚úÖ convert v·ªÅ BigInt v√¨ account.id trong Prisma l√† BigInt
        const accountId = BigInt(payload.sub);

        const hashed = await bcrypt.hash(newPassword, 10);

        await this.prisma.account.update({
          where: { id: accountId },
          data: { password: hashed },
        });

        return { message: 'Password reset successfully' };
      } catch {
        throw new BadRequestException('Invalid or expired token');
      }
    }

async getMe(accountId: bigint) {
  try {
    const account = await this.prisma.account.findUnique({
      where: { id: accountId },
      include: { user: true, company: true },
    });

    if (!account) {
      throw new BadRequestException('Account not found');
    }

    const { password, ...safeData } = account;

    // Convert BigInt -> string tr∆∞·ªõc khi return
    const transformBigInt = (obj: any) =>
      JSON.parse(
        JSON.stringify(obj, (_, value) =>
          typeof value === 'bigint' ? value.toString() : value,
        ),
      );

    return transformBigInt(safeData);
  } catch (error) {
    throw error;
  }
}

async logout(accountId: bigint, res: Response) {
  await this.prisma.account.update({
    where: { id: accountId },
    data: { refreshToken: null },
  });

  // d√πng l·∫°i cookieBase() cho ƒë·ªìng b·ªô v·ªõi l√∫c set
  res.clearCookie('access_token', this.cookieBase());
  res.clearCookie('refresh_token', this.cookieBase());

  return { message: 'Logout successful' };
}
async verifyResetToken(token: string) {
  try {
    const payload = await this.jwtService.verifyAsync(token);
    if (payload.purpose !== "reset-password") {
      throw new BadRequestException("Invalid token purpose");
    }
    return { valid: true };
  } catch (e) {
    throw new BadRequestException("Token invalid or expired");
    }
  }
}