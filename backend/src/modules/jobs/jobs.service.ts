import {
  Injectable,
  NotFoundException,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '@/prisma/prisma.service';
import { ElasticsearchJobService } from '../elasticsearch/job.elasticsearch.service';
import { LocationService } from '../location/location.service';
import { CreateJobDto } from './dto/create-job.dto';
import { UpdateJobDto } from './dto/update-job.dto';
import {Cron, CronExpression} from "@nestjs/schedule";
@Injectable()
export class JobsService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly esJob: ElasticsearchJobService,
    private readonly locationService: LocationService,
  ) {}

  // -----------------------------
  // CREATE JOB (Recruiter)
  // -----------------------------
  async create(accountId: bigint, dto: CreateJobDto) {
    try {
      const { skill_ids, description, requirements, ...data } = dto;

      // ‚úÖ L·∫•y c√¥ng ty c·ªßa recruiter
      const company = await this.prisma.company.findUnique({
        where: { account_id: accountId },
      });
      if (!company) {
        throw new NotFoundException('Nh√† tuy·ªÉn d·ª•ng ch∆∞a c√≥ c√¥ng ty h·ª£p l·ªá');
      }

      // ‚úÖ Gh√©p ƒë·ªãa ch·ªâ ƒë·∫ßy ƒë·ªß
      const parts = [
        data.location_street,
        data.location_ward,
        data.location_district,
        data.location_city,
      ].filter(Boolean);
      const location_full = parts.join(', ');

      // ‚úÖ T·ª± ƒë·ªông l·∫•y to·∫° ƒë·ªô (n·∫øu c√≥ ƒë·ªãa ch·ªâ)
      let latitude = data.latitude ?? null;
      let longitude = data.longitude ?? null;
      if (!latitude && !longitude && location_full) {
        const geo = await this.locationService.geocodeAddress(location_full);
        latitude = geo.latitude;
        longitude = geo.longitude;
      }
      

      // ‚úÖ T·∫°o job ch√≠nh
      const job = await this.prisma.job.create({
        data: {
            company_id: company.id,
            ...data,
            ...(data.category_id ? { category_id: BigInt(data.category_id) } : {}),
            location_full,
            latitude,
            longitude,
            number_of_openings: data.number_of_openings ?? 1,
            details: {
            create: {
                description,
                requirements,
            },
            },
            deadline: data.deadline ? new Date(data.deadline) : null,
        } as any, // t·∫°m th·ªùi b·ªè qua l·ªói ki·ªÉu d·ªØ li·ªáu bigint
        include: { company: true },
        });

      // ‚úÖ G·∫Øn k·ªπ nƒÉng n·∫øu c√≥
      if (skill_ids?.length) {
        await this.prisma.jobSkill.createMany({
          data: skill_ids.map((id) => ({
            job_id: job.id,
            skill_id: id,
          })),
        });
      }

      // ‚úÖ L·∫•y l·∫°i d·ªØ li·ªáu ƒë·∫ßy ƒë·ªß ƒë·ªÉ index
      const fullJob = await this.getFullJob(job.id);

      // ‚úÖ Index v√†o Elasticsearch
      await this.esJob.indexJob(fullJob);

      return fullJob;
    } catch (error) {
      console.error('üî• L·ªói t·∫°o job:', error);
      throw new InternalServerErrorException('Kh√¥ng th·ªÉ t·∫°o job: ' + error.message);
    }
  }

   // UPDATE JOB (Recruiter)
  // -----------------------------
  async update(jobId: bigint, dto: UpdateJobDto) {
    try {
      const { skill_ids, description, requirements, ...data } = dto;

      // ‚úÖ Ki·ªÉm tra job t·ªìn t·∫°i
      const job = await this.prisma.job.findUnique({
        where: { id: jobId },
        include: { details: true },
      });
      if (!job) throw new NotFoundException('Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác');

      // ‚úÖ Gh√©p location_full n·∫øu c√≥ b·∫•t k·ª≥ field ƒë·ªãa ch·ªâ n√†o thay ƒë·ªïi
      let location_full = job.location_full;
      if (
        data.location_city ||
        data.location_district ||
        data.location_ward ||
        data.location_street
      ) {
        const parts = [
          data.location_street ?? job.location_street,
          data.location_ward ?? job.location_ward,
          data.location_district ?? job.location_district,
          data.location_city ?? job.location_city,
        ].filter(Boolean);
        location_full = parts.join(', ');
      }

      // ‚úÖ T√≠nh l·∫°i to·∫° ƒë·ªô n·∫øu c√≥ thay ƒë·ªïi ƒë·ªãa ch·ªâ ho·∫∑c latitude/longitude ƒë∆∞·ª£c g·ª≠i m·ªõi
      let latitude = data.latitude ?? job.latitude;
      let longitude = data.longitude ?? job.longitude;
      if (
        (data.location_city ||
          data.location_district ||
          data.location_ward ||
          data.location_street) &&
        location_full
      ) {
        const geo = await this.locationService.geocodeAddress(location_full);
        latitude = geo.latitude;
        longitude = geo.longitude;
      }

      // ‚úÖ Chu·∫©n h√≥a deadline & category_id
      const deadline = data.deadline
        ? new Date(data.deadline)
        : job.deadline;
      const category_id =
        data.category_id !== undefined
          ? BigInt(data.category_id as any)
          : job.category_id;
    const updateDetailData: any = {};
    if (description !== undefined) updateDetailData.description = description;
    if (requirements !== undefined) updateDetailData.requirements = requirements;

      // ‚úÖ C·∫≠p nh·∫≠t job ch√≠nh
      const updatedJob = await this.prisma.job.update({
        where: { id: jobId },
        data: {
          ...data,
          category_id,
          location_full,
          latitude,
          longitude,
          deadline,
          details: {
            upsert: {
              update: { ...updateDetailData },
              create: { description, requirements },
            },
          },
        },
        include: { company: true, category: true },
      });

      // ‚úÖ N·∫øu c√≥ skill_ids g·ª≠i l√™n => thay to√†n b·ªô
      if (skill_ids !== undefined) {
        await this.prisma.jobSkill.deleteMany({ where: { job_id: jobId } });
        if (skill_ids.length) {
          await this.prisma.jobSkill.createMany({
            data: skill_ids.map((id) => ({
              job_id: jobId,
              skill_id: id,
            })),
          });
        }
      }

      // ‚úÖ L·∫•y l·∫°i job ƒë·∫ßy ƒë·ªß ƒë·ªÉ index
      const fullJob = await this.getFullJob(jobId);

      // ‚úÖ C·∫≠p nh·∫≠t Elasticsearch
      await this.esJob.updateJob(fullJob);

      return fullJob;
    } catch (error) {
      console.error('üî• L·ªói c·∫≠p nh·∫≠t job:', error);
      throw new InternalServerErrorException('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t job: ' + error.message);
    }
  }

  async updateStatus(
  jobId: bigint,
  status: 'active' | 'hidden' | 'closed' | 'expired',
) {
  try {
    const job = await this.prisma.job.findUnique({ where: { id: jobId } });
    if (!job) throw new NotFoundException('Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác');

    if (status === 'expired') {
      throw new BadRequestException(
        "Kh√¥ng th·ªÉ chuy·ªÉn tr·∫°ng th√°i th·ªß c√¥ng sang 'expired' ‚Äî h·ªá th·ªëng s·∫Ω t·ª± ƒë√°nh d·∫•u khi qu√° h·∫°n.",
      );
    }
    const validTransitions: Record<string, string[]> = {
      active: ['hidden', 'closed'],
      hidden: ['active'],
      closed: [],
      expired: [],
    };

    const currentStatus = job.status;
    const allowedNext = validTransitions[currentStatus];
    if (!allowedNext.includes(status)) {
      throw new BadRequestException(
        `Kh√¥ng th·ªÉ chuy·ªÉn t·ª´ tr·∫°ng th√°i '${currentStatus}' sang '${status}'`,
      );
    }

    const updatedJob = await this.prisma.job.update({
      where: { id: jobId },
      data: { status },
    });

    // ƒê·ªìng b·ªô elasticsearch
    if (status === 'active') {
      // ‚úÖ Active ‚Üí reindex v√†o Elasticsearch
      const fullJob = await this.getFullJob(jobId);
      await this.esJob.indexJob(fullJob);
    } else {
      // ‚ùå Hidden ho·∫∑c Closed ‚Üí x√≥a kh·ªèi Elasticsearch
      await this.esJob.removeJob(jobId);
    }

    return updatedJob;
  } catch (error) {
    console.error('üî• L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i job:', error);
    throw new InternalServerErrorException(
      'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i: ' + error.message,
    );
  }
}

@Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
async autoExpireJobs() {
    const now = new Date();

    // 1Ô∏è‚É£ L·∫•y t·∫•t c·∫£ job ƒëang active nh∆∞ng qu√° deadline
    const expiredJobs = await this.prisma.job.findMany({
      where: {
        status: 'active',
        deadline: { lt: now },
      },
      select: { id: true },
    });

    if (!expiredJobs.length) {
      console.log('‚úÖ Kh√¥ng c√≥ job n√†o h·∫øt h·∫°n h√¥m nay.');
      return;
    }

    const jobIds = expiredJobs.map((j) => j.id);

    // 2Ô∏è‚É£ C·∫≠p nh·∫≠t tr·∫°ng th√°i sang expired
    await this.prisma.job.updateMany({
      where: { id: { in: jobIds } },
      data: { status: 'expired' },
    });

    // 3Ô∏è‚É£ X√≥a kh·ªèi Elasticsearch
    for (const jobId of jobIds) {
      try {
        await this.esJob.removeJob(jobId);
      } catch (err) {
        console.error(`‚ö†Ô∏è L·ªói x√≥a job ${jobId} kh·ªèi Elasticsearch:`, err);
      }
    }

    console.log(`üöÄ ƒê√£ chuy·ªÉn ${jobIds.length} job sang 'expired' v√† x√≥a kh·ªèi Elasticsearch`);
  }

  
  // H√†m SearhJobs (g·ªçi elasticsearch)
  async search(query: any) {
    const work_modes = this.safeParseArray(query.work_modes);
    const experience_levels = this.safeParseArray(query.experience_levels);
    const skills = this.safeParseArray(query.skills);
    const employment_type = this.safeParseArray(query.employment_type);
    try {
      return await this.esJob.searchJobs({
        keyword: query.keyword,

        city: query.city,
        district: query.district,
        ward: query.ward,
        street: query.street,

          work_modes,
          experience_levels,
          skills,
          employment_type,

        negotiable:
          query.negotiable !== undefined
            ? String(query.negotiable) === 'true'
            : undefined,
        category: query.category,

        min_salary:
          query.min_salary !== undefined ? Number(query.min_salary) : undefined,
        max_salary:
          query.max_salary !== undefined ? Number(query.max_salary) : undefined,

        lat: query.lat !== undefined ? Number(query.lat) : undefined,
        lon: query.lon !== undefined ? Number(query.lon) : undefined,
        radius_km:
          query.radius_km !== undefined ? Number(query.radius_km) : undefined,

        page: query.page ? Number(query.page) : 1,
        limit: query.limit ? Number(query.limit) : 10,
        sort: query.sort,
      });
    } catch (e) {
      console.error('‚ùå L·ªói search job:', e);
      throw new InternalServerErrorException('Kh√¥ng th·ªÉ t√¨m ki·∫øm c√¥ng vi·ªác');
    }
  }

  // H√†m g·ª£i √Ω c√¥ng vi·ªác:
  async suggest(q: string) {
    try {
      if (!q || !q.trim()) return [];
      return await this.esJob.suggestJobs(q);
    } catch (e) {
      console.error('‚ùå L·ªói suggest job:', e);
      throw new InternalServerErrorException('Kh√¥ng th·ªÉ g·ª£i √Ω t·ª´ kh√≥a');
    }
  }

  // L·∫•y ra to√†n b·ªô th√¥ng tin c·ªßa m·ªôt job:
  async getOne(id: bigint, mode: 'public' | 'edit' = 'public') {
  const job = await this.getFullJob(id);
  if (!job) throw new NotFoundException('Kh√¥ng t√¨m th·∫•y c√¥ng vi·ªác');

  // N·∫øu public m√† job ch∆∞a active ho·∫∑c c√¥ng ty ch∆∞a approved th√¨ ·∫©n
  if (
    mode === 'public' &&
    (job.status !== 'active' || job.company.status !== 'approved')
  ) {
    throw new NotFoundException('C√¥ng vi·ªác kh√¥ng kh·∫£ d·ª•ng');
  }

  // ---------------------
  // 1Ô∏è‚É£ Base data d√πng chung
  // ---------------------
  const baseData = {
    id: job.id,
    title: job.title,
    salary_min: job.salary_min,
    salary_max: job.salary_max,
    negotiable: job.negotiable,
    employment_type: job.employment_type,
    location_city: job.location_city,
    work_modes: job.work_modes,
    experience_levels: job.experience_levels,
    status: job.status,
    deadline: job.deadline,
    location: { full: job.location_full },
    description: job.details?.description,
    requirements: job.details?.requirements,
    category: job.category
      ? { id: job.category.id, name: job.category.name }
      : null,
    skills: job.skills.map((js) => js.skill.name),
    company: {
      id: job.company.id,
      name: job.company.name,
      logo_url: job.company.logo_url,
      address: job.company.address,
      industries: job.company.industry_info.map((ci) => ci.industry.name),
      tech_stacks: job.company.skills.map((cs) => cs.skill.name),
      company_website: job.company.website,
    },
    created_at: job.created_at,
    updated_at: job.updated_at,
  };

  // ---------------------
  // 2Ô∏è‚É£ Mode x·ª≠ l√Ω
  // ---------------------

  // üü¢ Public mode ‚Üí ch·ªâ tr·∫£ th√¥ng tin hi·ªÉn th·ªã
  if (mode === 'public') {
    return baseData;
  }

  // üü£ Edit mode ‚Üí th√™m c√°c field ph·ª•c v·ª• form ch·ªânh s·ª≠a
  return {
    ...baseData,
    category_id: job.category_id,
    skill_ids: job.skills.map((js) => js.skill_id),
    company_id: job.company_id,
    location_city: job.location_city,
    location_district: job.location_district,
    location_ward: job.location_ward,
    location_street: job.location_street,
    latitude: job.latitude,
    longitude: job.longitude,
  };
}


  

  // -----------------------------
  // Helper: L·∫•y full job
  // -----------------------------
  private async getFullJob(id: bigint) {
  return await this.prisma.job.findUnique({
    where: { id },
    include: {
      details: true,
      category: true,
      skills: { include: { skill: true } },
      company: {
        include: {
          industry_info: { include: { industry: true } },
          skills: { include: { skill: true } },
        },
      },
    },
  });
}

  // -----------------------------
  // Helper:  parse m·∫£ng an to√†n t·ª´ query string
  // -----------------------------
  private safeParseArray(value: any): string[] | undefined {
    if (!value) return undefined;
    if (Array.isArray(value)) return value; // ?param=a&param=b
    if (typeof value === 'string') {
      // N·∫øu frontend g·ª≠i JSON string ["a","b"]
      if (value.startsWith('[')) {
        try {
          return JSON.parse(value);
        } catch {
          return [value];
        }
      }
      // N·∫øu ch·ªâ g·ª≠i ?param=a
      return [value];
    }
    return undefined;
  }
}