import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '@/prisma/prisma.service';
import { CreateApplicationDto } from './dto/create-application.dto';
import { ApplicationStatus } from '@prisma/client';

@Injectable()
export class ApplicationService {
  constructor(private readonly prisma: PrismaService) {}
// === Ch·ª©c nƒÉng d√†nh cho candidate==========
  // L·∫•y candidate_id t·ª´ userId
  private async getCandidateIdByUserId(userId: bigint): Promise<bigint> {
    const candidate = await this.prisma.candidate.findUnique({
      where: { user_id: userId },
      select: { id: true },
    });
    if (!candidate)
      throw new ForbiddenException('T√†i kho·∫£n kh√¥ng c√≥ h·ªì s∆° ·ª©ng vi√™n.');
    return candidate.id;
  }
  // ·ª®ng tuy·ªÉn c√¥ng vi·ªác
  async apply(userId: bigint, dto: CreateApplicationDto) {
    try {
      // Convert string IDs sang bigint:
      const jobId= BigInt(dto.job_id);
      const cvId= BigInt(dto.cv_id);

      const candidateId = await this.getCandidateIdByUserId(userId);

      // 1Ô∏è‚É£ Ki·ªÉm tra job c√≥ t·ªìn t·∫°i v√† ƒëang active
      const job = await this.prisma.job.findFirst({
        where: { id: jobId, status: 'active' },
      });
      if (!job)
        throw new NotFoundException('C√¥ng vi·ªác kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã ƒë√≥ng.');

      // 2Ô∏è‚É£ Ki·ªÉm tra CV c√≥ thu·ªôc v·ªÅ ·ª©ng vi√™n kh√¥ng
      const cv = await this.prisma.cv.findFirst({
        where: { id: cvId, candidate_id: candidateId, is_deleted: false },
      });
      if (!cv) throw new ForbiddenException('CV kh√¥ng h·ª£p l·ªá.');

      // 3Ô∏è‚É£ Ki·ªÉm tra ·ª©ng vi√™n ƒë√£ n·ªôp ƒë∆°n ch∆∞a (tr√°nh tr√πng)
      const application = await this.checkAlreadyApplied(userId, jobId);
      if (application.applied)
        throw new BadRequestException('B·∫°n ƒë√£ ·ª©ng tuy·ªÉn c√¥ng vi·ªác n√†y r·ªìi.');

      // 4Ô∏è‚É£ T·∫°o ƒë∆°n ·ª©ng tuy·ªÉn m·ªõi
      const app = await this.prisma.application.create({
        data: {
          job_id: jobId,
          candidate_id: candidateId,
          cv_id: cvId,
        },
      });
      return app;
    } catch (error) {
      console.error('‚ùå L·ªói khi ·ª©ng tuy·ªÉn:', error);
      throw new InternalServerErrorException('ƒê√£ x·∫£y ra l·ªói khi n·ªôp ƒë∆°n ·ª©ng tuy·ªÉn.');
    }
  }

  // L·∫•y to√†n b·ªô vi·ªác l√†m ƒë√£ ·ª©ng tuy·ªÉn (·ªü m·ª©c t√≥m t·∫Øt t·ª´ng job)
  async getMyApplications(userId: bigint, page = 1, limit = 10, status?: ApplicationStatus) {
    const candidateId = await this.getCandidateIdByUserId(userId);
    const skip = (page - 1) * limit;

    const whereClause: any = { candidate_id: candidateId };
    if (status) whereClause.status = status;

    const [items, total] = await this.prisma.$transaction([
      this.prisma.application.findMany({
        where: whereClause,
        include: {
          job: {
            select: {
              id: true,
              title: true,
              company: { select: { id: true, name: true, logo_url: true } },
            },
          },
          cv: { select: { id: true, title: true, file_url: true } },
        },
        orderBy: { applied_at: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.application.count({ where: whereClause }),
    ]);

    return {
      items,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    };
  }

  // Xem chi ti·∫øt 1 ƒë∆°n ·ª©ng tuy·ªÉn d√†nh cho ·ª©ng vi√™n

  async getMyApplicationDetail(userId: bigint, appId: bigint) {
    const candidateId = await this.getCandidateIdByUserId(userId);
    const app = await this.prisma.application.findFirst({
      where: { id: appId, candidate_id: candidateId },
      include: {
        job: {
          include: {
            company: { select: { id: true, name: true, logo_url: true } },
          },
        },
        cv: true,
      },
    });

    if (!app) throw new NotFoundException('Kh√¥ng t√¨m th·∫•y ƒë∆°n ·ª©ng tuy·ªÉn.');

    return app;
  }

  // R√∫t l·∫°i ƒë∆°n ·ª©ng tuy·ªÉn:
  async withdrawApplication(userId: bigint, appId: bigint) {
    const candidateId = await this.getCandidateIdByUserId(userId);

    const app = await this.prisma.application.findFirst({
      where: { id: appId, candidate_id: candidateId },
    });

    if (!app) throw new NotFoundException('ƒê∆°n ·ª©ng tuy·ªÉn kh√¥ng t·ªìn t·∫°i.');
    if (app.status !== ApplicationStatus.pending)
      throw new BadRequestException(
        'Ch·ªâ c√≥ th·ªÉ r√∫t ƒë∆°n khi ƒëang ·ªü tr·∫°ng th√°i ch·ªù x·ª≠ l√Ω (pending).',
      );

    const updated = await this.prisma.application.update({
      where: { id: app.id },
      data: { status: ApplicationStatus.withdrawn },
    });

    return { message: 'ƒê√£ r√∫t ƒë∆°n ·ª©ng tuy·ªÉn th√†nh c√¥ng.', application: updated };
  }

  async checkAlreadyApplied(userId: bigint, jobId: bigint) {
    const candidateId = await this.getCandidateIdByUserId(userId);

    const application = await this.prisma.application.findFirst({
      where: {
        candidate_id: candidateId,
        job_id: jobId,
        status: { not: 'withdrawn' },
      },
      select: { id: true, status: true, applied_at: true },
    });

    if (application) {
      return {
        jobId,
        applied: true,
        status: application.status,
        applied_at: application.applied_at,
        message: '·ª®ng vi√™n ƒë√£ ·ª©ng tuy·ªÉn c√¥ng vi·ªác n√†y.',
      };
    }

    return {
      jobId,
      applied: false,
      message: '·ª®ng vi√™n ch∆∞a ·ª©ng tuy·ªÉn c√¥ng vi·ªác n√†y.',
    };
}


/// ===== Ch·ª©c nƒÉng d√†nh cho nh√† tuy·ªÉn d·ª•ng recruiter======

// L·∫•y to√†n b·ªô ƒë∆°n ·ª©ng tuy·ªÉn cho c√¥ng ty c·ªßa recruiter - thi·∫øt k·∫ø d·∫°ng b·∫£ng
  async getApplicationsByCompany(
  accountId: bigint,
  page = 1,
  limit = 10,
  status?: ApplicationStatus,
  jobId?: bigint,
  search?: string,
) {
  const start = Date.now();

  try {
    console.log(
      `üì© [getApplicationsByCompany] accountId=${accountId?.toString?.()} page=${page} limit=${limit} status=${status} jobId=${jobId} search="${search || ''}"`
    );

    // üî∏ 1Ô∏è‚É£ Ki·ªÉm tra recruiter c√≥ c√¥ng ty ch∆∞a
    const company = await this.prisma.company.findUnique({
      where: { account_id: accountId },
      select: { id: true, name: true },
    });
    if (!company) {
      console.warn(`‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c√¥ng ty cho accountId=${accountId}`);
      throw new ForbiddenException('B·∫°n ch∆∞a c√≥ c√¥ng ty.');
    }

    // üîπ 2Ô∏è‚É£ X√¢y d·ª±ng whereClause an to√†n v·ªõi Prisma 6
    const whereClause: any = {
      AND: [
        { job: { company_id: company.id } }, // c√¥ng ty c·ªßa recruiter
      ],
    };

    if (status) whereClause.AND.push({ status });
    if (jobId) whereClause.AND.push({ job: { id: jobId } });

    // üîç 3Ô∏è‚É£ Filter theo t·ª´ kh√≥a t√¨m ki·∫øm
    if (search && search.trim()) {
    whereClause.AND.push({
      OR: [
        {
          candidate: {
            is: {
              user: {
                is: {
                  full_name: { contains: search },
                },
              },
            },
          },
        },
        {
          candidate: {
            is: {
              user: {
                is: {
                  account: {
                    is: {
                      email: { contains: search },
                    },
                  },
                },
              },
            },
          },
        },
        {
          candidate: {
            is: {
              user: {
                is: {
                  phone: { contains: search },
                },
              },
            },
          },
        },
      ],
    });
  }

    // üîπ 4Ô∏è‚É£ Pagination
    const skip = (page - 1) * limit;

    // üîç 5Ô∏è‚É£ Th·ª±c thi query (transaction: list + count)
    const [items, total] = await this.prisma.$transaction([
      this.prisma.application.findMany({
        where: whereClause,
        include: {
          job: { select: { id: true, title: true } },
          candidate: {
            include: {
              user: {
                select: {
                  id: true,
                  full_name: true,
                  phone: true,
                  avatar_url: true,
                  account: { select: { email: true } },
                },
              },
            },
          },
        },
        orderBy: { applied_at: 'desc' },
        skip,
        take: limit,
      }),
      this.prisma.application.count({ where: whereClause }),
    ]);

    console.log(
      `‚úÖ L·∫•y ${items.length} ƒë∆°n | total=${total} | ${Date.now() - start}ms`
    );

    return {
      items,
      total,
      page,
      pages: Math.ceil(total / limit),
    };
  } catch (error) {
    console.error('‚ùå L·ªói trong getApplicationsByCompany:', error.message);
    console.error(error.stack?.split('\n')[0]);
    throw new InternalServerErrorException(
      error.message || 'L·ªói khi l·∫•y danh s√°ch ·ª©ng tuy·ªÉn c√¥ng ty.'
    );
  }
}
  async getApplicationDetailByCompany(recruiterId: bigint, appId: bigint) {
    const company = await this.prisma.company.findUnique({
      where: { account_id: recruiterId },
    });
    if (!company) throw new ForbiddenException('B·∫°n ch∆∞a c√≥ c√¥ng ty.');

    const app = await this.prisma.application.findFirst({
      where: {
        id: appId,
        job: { company_id: company.id },
      },
      include: {
        job: {
          select: {
            id: true,
            title: true,
            company: { select: { id: true, name: true, logo_url: true } },
          },
        },
        candidate: {
          include: {
            user: {
              select: {
                full_name: true,
                phone: true,
                avatar_url: true,
                dob: true,
                gender: true,
                account: { select: { email: true } },
              },
            },
          },
        },
        cv: {
          select: {
            id: true,
            title: true,
            file_url: true,
            content: true,
            template_id: true,
          },
        },
      },
    });

    if (!app) throw new NotFoundException('ƒê∆°n ·ª©ng tuy·ªÉn kh√¥ng t·ªìn t·∫°i.');

    const cvType = app.cv?.file_url
      ? 'file'
      : app.cv?.content
      ? 'online'
      : 'unknown';

    const formattedCv =
      cvType === 'file'
        ? {
            type: 'file',
            title: app.cv.title,
            file_url: app.cv.file_url,
          }
        : cvType === 'online'
        ? {
            type: 'online',
            title: app.cv.title,
            template_id: app.cv.template_id,
            content: app.cv.content,
          }
        : null;

    return {
      id: app.id,
      status: app.status,
      applied_at: app.applied_at,
      job: app.job,
      candidate: app.candidate,
      cv: formattedCv,
    };
}

async acceptApplication(accountId: bigint, appId: bigint) {
  const company = await this.prisma.company.findUnique({
    where: { account_id: accountId },
  });
  if (!company) throw new ForbiddenException('B·∫°n ch∆∞a c√≥ c√¥ng ty.');

  const app = await this.prisma.application.findFirst({
    where: { id: appId, job: { company_id: company.id } },
  });
  if (!app) throw new NotFoundException('ƒê∆°n ·ª©ng tuy·ªÉn kh√¥ng t·ªìn t·∫°i.');
  if (app.status !== ApplicationStatus.pending)
    throw new BadRequestException('Ch·ªâ c√≥ th·ªÉ duy·ªát ƒë∆°n ƒëang ·ªü tr·∫°ng th√°i pending.');

  const updated = await this.prisma.application.update({
    where: { id: app.id },
    data: { status: ApplicationStatus.accepted },
  });

  // TODO: g·ª≠i th√¥ng b√°o realtime ho·∫∑c email cho ·ª©ng vi√™n ·ªü ƒë√¢y
  return { message: 'ƒê√£ duy·ªát ƒë∆°n ·ª©ng tuy·ªÉn.', application: updated };
}

async rejectApplication(accountId: bigint, appId: bigint) {
  const company = await this.prisma.company.findUnique({
    where: { account_id: accountId },
  });
  if (!company) throw new ForbiddenException('B·∫°n ch∆∞a c√≥ c√¥ng ty.');

  const app = await this.prisma.application.findFirst({
    where: { id: appId, job: { company_id: company.id } },
  });
  if (!app) throw new NotFoundException('ƒê∆°n ·ª©ng tuy·ªÉn kh√¥ng t·ªìn t·∫°i.');
  if (app.status !== ApplicationStatus.pending)
    throw new BadRequestException('Ch·ªâ c√≥ th·ªÉ t·ª´ ch·ªëi ƒë∆°n ƒëang ·ªü tr·∫°ng th√°i pending.');

  const updated = await this.prisma.application.update({
    where: { id: app.id },
    data: { status: ApplicationStatus.rejected },
  });

  // TODO: g·ª≠i notification cho ·ª©ng vi√™n
  return { message: 'ƒê√£ t·ª´ ch·ªëi ƒë∆°n ·ª©ng tuy·ªÉn.', application: updated };
}
}