import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '@/prisma/prisma.service';
import { CloudinaryService } from '@/modules/cloudinary/cloudinary.service';
import { CreateCvDto } from './dto/create-cv.dto';
import { UpdateCvDto } from './dto/update-cv.dto';
import { CvType } from '@prisma/client';
@Injectable()
export class CvsService {
  private readonly logger = new Logger(CvsService.name);
  constructor(
    private readonly prisma: PrismaService,
    private readonly cloudinary: CloudinaryService,
  ) {}

   private async getCandidateIdByUserId(userId: bigint): Promise<bigint> {
    const candidate = await this.prisma.candidate.findUnique({
      where: { user_id: userId },
      select: { id: true },
    });
    if (!candidate) {
      throw new ForbiddenException('T√†i kho·∫£n hi·ªán kh√¥ng c√≥ h·ªì s∆° ·ª©ng vi√™n (candidate).');
    }
    return candidate.id;
  }

  private formatCvData(cv: any) {
    if (!cv) return null;

    // ∆Øu ti√™n ƒë·ªçc field type t·ª´ DB (CvType)
    const type =
      cv.type === CvType.FILE || cv.file_url ? 'file' :
      cv.type === CvType.ONLINE || cv.content ? 'online' : 'unknown';

    if (type === 'file') {
      return {
        type: 'file',
        id: cv.id,
        title: cv.title,
        file_url: cv.file_url,
        created_at: cv.created_at,
        updated_at: cv.updated_at,
      };
    }

    if (type === 'online') {
      return {
        type: 'online',
        id: cv.id,
        title: cv.title,
        template_id: cv.template_id,
        template: cv.template
          ? {
              id: cv.template.id,
              name: cv.template.name,
              preview_url: cv.template.preview_url,
            }
          : null,
        content: cv.content,
        created_at: cv.created_at,
        updated_at: cv.updated_at,
      };
    }

    return {
      type: 'unknown',
      id: cv.id,
      title: cv.title,
    };
  }

  async createCV(userId: bigint, dto: CreateCvDto) {
    try {
        const candidateId = await this.getCandidateIdByUserId(userId);

        if (!candidateId) {
        throw new NotFoundException('Kh√¥ng t√¨m th·∫•y candidate t∆∞∆°ng ·ª©ng v·ªõi user n√†y');
        }

        const cv = await this.prisma.cv.create({
        data: {
            candidate_id: candidateId,
            title: dto.title,
            template_id: dto.template_id,
            content: dto.content,
            type: CvType.ONLINE,
        },
        });

        return cv;
    } catch (error) {
        console.error('‚ùå L·ªói khi t·∫°o CV:', error);

        if (error instanceof NotFoundException) {
        throw error;
        }

        throw new InternalServerErrorException('Kh√¥ng th·ªÉ t·∫°o CV, vui l√≤ng th·ª≠ l·∫°i sau');
    }
}
    // H√†m l·∫•y to√†n b·ªô CV c·ªßa m·ªôt candidate
    async listMyCvsByType(
    userId: bigint,
    type: CvType, // 'ONLINE' | 'FILE'
    page: number,
    limit: number,
  ) {
    try {
      const candidate = await this.prisma.candidate.findUnique({
        where: { user_id: userId },
        select: { id: true },
      });
      if (!candidate)
        throw new NotFoundException(
          'Kh√¥ng t√¨m th·∫•y candidate t∆∞∆°ng ·ª©ng v·ªõi user n√†y',
        );

      const skip = (page - 1) * limit;

      const [items, total] = await this.prisma.$transaction([
        this.prisma.cv.findMany({
          where: {
            candidate_id: candidate.id,
            is_deleted: false,
            type,
          },
          orderBy: { created_at: 'desc' },
          skip,
          take: limit,
          include:
            type === CvType.ONLINE
              ? { template: { select: { id: true, name: true, preview_url: true } } }
              : undefined,
        }),
        this.prisma.cv.count({
          where: {
            candidate_id: candidate.id,
            is_deleted: false,
            type,
          },
        }),
      ]);

      // Chu·∫©n h√≥a to√†n b·ªô danh s√°ch
      const formattedItems = items.map((cv) => this.formatCvData(cv));

      return {
        items: formattedItems,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      console.error('‚ùå L·ªói khi l·∫•y danh s√°ch CV:', error);
      throw new InternalServerErrorException(
        'Kh√¥ng th·ªÉ l·∫•y danh s√°ch CV, vui l√≤ng th·ª≠ l·∫°i sau',
      );
    }
  }

// L·∫•y chi ti·∫øt CV theo ID
    async getMyCvDetail(cvId: bigint) {
    const cv = await this.prisma.cv.findFirst({
      where: { id: cvId, is_deleted: false },
      include: {
        template: {
          select: { id: true, name: true, preview_url: true },
        },
      },
    });

    if (!cv) throw new NotFoundException('CV kh√¥ng t·ªìn t·∫°i.');

    return this.formatCvData(cv);
  }
    // C·∫≠p nh·∫≠t CV
    async updateMyCv(cvId: bigint, dto: UpdateCvDto) {

        const cv = await this.prisma.cv.findFirst({ where: { id: cvId, is_deleted: false } });
        if (!cv) throw new NotFoundException('CV kh√¥ng t·ªìn t·∫°i.');

        // ‚úÖ Ch·ªâ truy·ªÅn nh·ªØng field th·ª±c s·ª± c√≥ trong DTO
        return this.prisma.cv.update({
            where: { id: cvId },
            data: {
            ...(dto.title && { title: dto.title }),
            ...(dto.template_id && { template_id: dto.template_id }),
            ...(dto.content && { content: dto.content }),
            },
        });
    }

    // X√≥a CV (soft delete)
    async deleteMyCv(cvId: bigint) {
        const cv = await this.prisma.cv.findFirst({
            where: { id: cvId, is_deleted: false },
        });
        if (!cv) throw new NotFoundException('CV kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã x√≥a.');
        const used = await this.prisma.application.count({ where: { cv_id: cvId } });

        //N·∫øu CV ƒëang d√πng ‚Üí soft delete
        if (used > 0) {
            return this.prisma.cv.update({
            where: { id: cvId },
            data: {
                is_deleted: true,
            },
            });
        }

        //N·∫øu ch∆∞a d√πng ‚Üí x√≥a th·∫≠t + cleanup Cloudinary
        if (cv.file_public_id) {
            try {
            await this.cloudinary.deleteFile(cv.file_public_id);
            } catch (err) {
            this.logger?.warn?.(
                `‚ö†Ô∏è L·ªói khi x√≥a file Cloudinary (${cv.file_public_id}): ${err.message}`,
            );
            }
        }

        return this.prisma.cv.delete({ where: { id: cvId } });
    }

//======X·ª≠ l√≠ cho tr∆∞·ªùng h·ª£p upload CV d·∫°ng file (PDF/Word) l√™n Cloudinary ======//


    async uploadFileCv(userId: bigint, file: Express.Multer.File, overrideTitle?: string) {
    if (!file) throw new BadRequestException('Kh√¥ng c√≥ file ƒë√≠nh k√®m.');

        const candidateId = await this.getCandidateIdByUserId(userId);
        const uploaded = await this.cloudinary.uploadDocument(file, 'cvs');

        return this.prisma.cv.create({
            data: {
            candidate_id: candidateId,
            title: overrideTitle || file.originalname,
            file_url: uploaded.secure_url,
            file_public_id: uploaded.public_id,
            type: CvType.FILE,
            },
        });
    }

    // Tr∆∞·ªùng h·ª£p ng∆∞·ªùi d√πng thay ƒë·ªïi file CV ƒë√£ upload
    async replaceFile(cvId: bigint, file: Express.Multer.File) {
        if (!file) throw new BadRequestException('Kh√¥ng c√≥ file ƒë√≠nh k√®m.');
        
        const cv = await this.prisma.cv.findFirst({ where: { id: cvId , is_deleted: false } });
        if (!cv) throw new NotFoundException('CV kh√¥ng t·ªìn t·∫°i.');

        // üßπ N·∫øu CV c√≥ file c≈© => x√≥a tr√™n Cloudinary
        if (cv.file_public_id) {
            try {
            await this.cloudinary.deleteFile(cv.file_public_id);
            } catch (err) {
            console.warn(`‚ö†Ô∏è L·ªói khi x√≥a file c≈© tr√™n Cloudinary: ${err.message}`);
            }
        }

        // üì§ Upload file m·ªõi
        const uploaded = await this.cloudinary.uploadDocument(file, 'cvs');

        return this.prisma.cv.update({
            where: { id: cvId },
            data: {
            file_url: uploaded.secure_url,
            file_public_id: uploaded.public_id,
            },
        });
    }


    async getPdfBuffer(filename: string): Promise<Buffer> {
    try {
      const cloudUrl = `https://res.cloudinary.com/dzgltugct/raw/upload/v1761391116/cvs/${filename}`;
      const response = await fetch(cloudUrl);

      if (!response.ok) {
        throw new NotFoundException('Kh√¥ng t√¨m th·∫•y file tr√™n Cloudinary');
      }

      const buffer = await response.arrayBuffer();
      return Buffer.from(buffer);
    } catch (error) {
      // N·∫øu l·ªói do m·∫°ng ho·∫∑c fetch th·∫•t b·∫°i
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new Error(`L·ªói khi t·∫£i file t·ª´ Cloudinary: ${error.message}`);
    }
  }


}