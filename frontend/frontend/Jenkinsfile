pipeline {
    agent any
    
    environment {
        // T√™n image v√† container
        IMAGE_NAME = 'itworks-frontend'
        CONTAINER_NAME = 'itworks-frontend'
        NGINX_IMAGE_NAME = 'itworks-nginx'
        NGINX_CONTAINER_NAME = 'itworks-nginx'
        DOCKER_NETWORK = 'itworks-network'
        
        // Port mapping
        APP_PORT = '80'
        NGINX_HTTP_PORT = '80'
        NGINX_HTTPS_PORT = '443'
        
        // Domain v√† SSL
        DOMAIN = 'itworks.dpdns.org'
        SSL_EMAIL = 'admin@itworks.dpdns.org'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'üì• Checking out code from GitHub...'
                checkout scm
            }
        }
        
        stage('Create Docker Network') {
            steps {
                script {
                    echo 'üåê Creating Docker network...'
                    sh """
                        docker network create ${DOCKER_NETWORK} 2>/dev/null || true
                    """
                }
            }
        }
        
        stage('Build Frontend Image') {
            steps {
                script {
                    echo 'üî® Building Frontend Docker image...'
                    dir('frontend/frontend') {
                        // Build frontend image v·ªõi tag
                        def imageTag = "${IMAGE_NAME}:${BUILD_NUMBER}"
                        def imageLatest = "${IMAGE_NAME}:latest"
                        
                        sh """
                            docker build -t ${imageTag} -t ${imageLatest} .
                        """
                        
                        echo "‚úÖ Frontend image built: ${imageTag}"
                    }
                }
            }
        }
        
        stage('Build Nginx Image') {
            steps {
                script {
                    echo 'üî® Building Nginx reverse proxy image...'
                    dir('frontend/frontend/nginx') {
                        // Build nginx image v·ªõi tag
                        def nginxImageTag = "${NGINX_IMAGE_NAME}:${BUILD_NUMBER}"
                        def nginxImageLatest = "${NGINX_IMAGE_NAME}:latest"
                        
                        sh """
                            docker build -t ${nginxImageTag} -t ${nginxImageLatest} .
                        """
                        
                        echo "‚úÖ Nginx image built: ${nginxImageTag}"
                    }
                }
            }
        }
        
        stage('Test') {
            steps {
                script {
                    echo 'üß™ Running tests...'
                    dir('frontend/frontend') {
                        // Ch·∫°y tests trong container (optional)
                        // sh 'docker run --rm ${IMAGE_NAME}:${BUILD_NUMBER} npm test'
                        echo '‚ö†Ô∏è  Tests skipped (uncomment to enable)'
                    }
                }
            }
        }
        
        stage('Stop Old Containers') {
            steps {
                script {
                    echo 'üõë Stopping old containers if exists...'
                    sh """
                        docker stop ${CONTAINER_NAME} ${NGINX_CONTAINER_NAME} || true
                        docker rm ${CONTAINER_NAME} ${NGINX_CONTAINER_NAME} || true
                    """
                }
            }
        }
        
        stage('Deploy Frontend') {
            steps {
                script {
                    echo 'üöÄ Deploying Frontend container...'
                    // Frontend kh√¥ng c·∫ßn expose port ra ngo√†i, ch·ªâ c·∫ßn trong Docker network
                    // Nginx s·∫Ω proxy ƒë·∫øn container n√†y
                    sh """
                        docker run -d \\
                            --name ${CONTAINER_NAME} \\
                            --restart unless-stopped \\
                            --network ${DOCKER_NETWORK} \\
                            ${IMAGE_NAME}:${BUILD_NUMBER}
                    """
                }
            }
        }
        
        stage('Setup SSL') {
            steps {
                script {
                    echo 'üîí Setting up SSL certificate...'
                    
                    // Ki·ªÉm tra quy·ªÅn sudo tr∆∞·ªõc
                    def hasSudo = sh(
                        script: "sudo -n true 2>&1 && echo 'yes' || echo 'no'",
                        returnStdout: true
                    ).trim()
                    
                    if (hasSudo == 'no') {
                        echo "‚ö†Ô∏è  Jenkins user kh√¥ng c√≥ quy·ªÅn sudo, b·ªè qua SSL setup"
                        echo "‚ÑπÔ∏è  ƒê·ªÉ enable SSL, c·∫ßn c·∫•u h√¨nh sudo cho Jenkins user:"
                        echo "   sudo visudo"
                        echo "   Th√™m d√≤ng: jenkins ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/certbot, /usr/bin/test"
                        env.SSL_EXISTS = 'not_exists'
                    } else {
                        // Ki·ªÉm tra SSL certificate ƒë√£ t·ªìn t·∫°i ch∆∞a
                        def sslExists = sh(
                            script: "sudo test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem && echo 'exists' || echo 'not_exists'",
                            returnStdout: true
                        ).trim()
                        
                        if (sslExists == 'not_exists') {
                            echo "üìù SSL certificate ch∆∞a t·ªìn t·∫°i, ƒëang t·∫°o m·ªõi..."
                            
                            // ƒê·∫£m b·∫£o port 80 free (stop Nginx container n·∫øu ƒëang ch·∫°y)
                            sh """
                                docker stop ${NGINX_CONTAINER_NAME} || true
                                docker rm ${NGINX_CONTAINER_NAME} || true
                            """
                            
                            // C√†i ƒë·∫∑t certbot v√† l·∫•y certificate
                            sh """
                                sudo apt-get update -qq || true
                                sudo apt-get install -y -qq certbot || true
                                sudo certbot certonly --standalone \\
                                    -d ${DOMAIN} \\
                                    -d www.${DOMAIN} \\
                                    --non-interactive \\
                                    --agree-tos \\
                                    --email ${SSL_EMAIL} \\
                                    --preferred-challenges http || echo "‚ö†Ô∏è  SSL certificate creation failed, will use HTTP"
                            """
                            
                            // Ki·ªÉm tra l·∫°i SSL
                            sslExists = sh(
                                script: "sudo test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem && echo 'exists' || echo 'not_exists'",
                                returnStdout: true
                            ).trim()
                        }
                        
                        env.SSL_EXISTS = sslExists
                    }
                    
                    dir('frontend/frontend/nginx') {
                        def sslExists = env.SSL_EXISTS ?: 'not_exists'
                        
                        if (sslExists == 'exists') {
                            echo "‚úÖ SSL certificate ƒë√£ t·ªìn t·∫°i, enabling HTTPS..."
                            
                            // Enable HTTPS trong nginx.conf
                            sh """
                                # Backup nginx.conf
                                cp nginx.conf nginx.conf.backup || true
                                
                                # Uncomment HTTPS server block
                                sed -i 's/# server {/server {/g' nginx.conf
                                sed -i 's/#     listen 443 ssl;/    listen 443 ssl;/g' nginx.conf
                                sed -i 's/#     http2 on;/    http2 on;/g' nginx.conf
                                sed -i 's/#     server_name/    server_name/g' nginx.conf
                                sed -i 's/#     ssl_certificate/    ssl_certificate/g' nginx.conf
                                sed -i 's/#     ssl_certificate_key/    ssl_certificate_key/g' nginx.conf
                                sed -i 's/#     ssl_protocols/    ssl_protocols/g' nginx.conf
                                sed -i 's/#     ssl_ciphers/    ssl_ciphers/g' nginx.conf
                                sed -i 's/#     ssl_prefer_server_ciphers/    ssl_prefer_server_ciphers/g' nginx.conf
                                sed -i 's/#     ssl_session_cache/    ssl_session_cache/g' nginx.conf
                                sed -i 's/#     ssl_session_timeout/    ssl_session_timeout/g' nginx.conf
                                sed -i 's/#     add_header/    add_header/g' nginx.conf
                                sed -i 's/#     gzip/    gzip/g' nginx.conf
                                sed -i 's/#     proxy_set_header/    proxy_set_header/g' nginx.conf
                                sed -i 's/#     proxy_connect_timeout/    proxy_connect_timeout/g' nginx.conf
                                sed -i 's/#     proxy_send_timeout/    proxy_send_timeout/g' nginx.conf
                                sed -i 's/#     proxy_read_timeout/    proxy_read_timeout/g' nginx.conf
                                sed -i 's/#     location/    location/g' nginx.conf
                                sed -i 's/#         proxy_pass/        proxy_pass/g' nginx.conf
                                sed -i 's/#         proxy_http_version/        proxy_http_version/g' nginx.conf
                                sed -i 's/#         proxy_set_header/        proxy_set_header/g' nginx.conf
                                sed -i 's/#         expires/        expires/g' nginx.conf
                                sed -i 's/#         add_header/        add_header/g' nginx.conf
                                sed -i 's/# }/}/g' nginx.conf
                                
                                # Enable HTTP to HTTPS redirect
                                sed -i 's/# return 301 https/return 301 https/g' nginx.conf
                            """
                            
                            // Rebuild Nginx image v·ªõi HTTPS enabled
                            sh """
                                docker build -t ${NGINX_IMAGE_NAME}:${BUILD_NUMBER} -t ${NGINX_IMAGE_NAME}:latest .
                            """
                            
                            echo "‚úÖ Nginx image ƒë√£ ƒë∆∞·ª£c rebuild v·ªõi HTTPS enabled"
                        } else {
                            echo "‚ö†Ô∏è  SSL certificate ch∆∞a ƒë∆∞·ª£c t·∫°o, s·∫Ω d√πng HTTP only"
                        }
                    }
                }
            }
        }
        
        stage('Deploy Nginx') {
            steps {
                script {
                    echo 'üöÄ Deploying Nginx reverse proxy container...'
                    
                    // Ki·ªÉm tra SSL c√≥ t·ªìn t·∫°i kh√¥ng (d√πng bi·∫øn t·ª´ stage tr∆∞·ªõc)
                    def sslExists = env.SSL_EXISTS ?: sh(
                        script: "sudo -n test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem 2>/dev/null && echo 'exists' || echo 'not_exists'",
                        returnStdout: true
                    ).trim()
                    
                    // Build docker run command
                    if (sslExists == 'exists') {
                        echo "‚úÖ Deploying v·ªõi SSL certificates"
                        sh """
                            docker run -d \\
                                --name ${NGINX_CONTAINER_NAME} \\
                                --restart unless-stopped \\
                                -p ${NGINX_HTTP_PORT}:80 \\
                                -p ${NGINX_HTTPS_PORT}:443 \\
                                -v /etc/letsencrypt:/etc/letsencrypt:ro \\
                                --network ${DOCKER_NETWORK} \\
                                ${NGINX_IMAGE_NAME}:${BUILD_NUMBER}
                        """
                    } else {
                        echo "‚ö†Ô∏è  Deploying kh√¥ng c√≥ SSL (HTTP only)"
                        sh """
                            docker run -d \\
                                --name ${NGINX_CONTAINER_NAME} \\
                                --restart unless-stopped \\
                                -p ${NGINX_HTTP_PORT}:80 \\
                                -p ${NGINX_HTTPS_PORT}:443 \\
                                --network ${DOCKER_NETWORK} \\
                                ${NGINX_IMAGE_NAME}:${BUILD_NUMBER}
                        """
                    }
                }
            }
        }
        
        stage('Health Check') {
            steps {
                script {
                    echo 'üè• Waiting for application to start...'
                    sleep(time: 10, unit: 'SECONDS')
                    
                    // Ki·ªÉm tra container c√≥ ch·∫°y kh√¥ng
                    sh """
                        if docker ps | grep -q ${CONTAINER_NAME}; then
                            echo "‚úÖ Frontend container is running"
                        else
                            echo "‚ùå Frontend container failed to start"
                            docker logs ${CONTAINER_NAME} || true
                            exit 1
                        fi
                    """
                    
                    // Ki·ªÉm tra Nginx container
                    sh """
                        if docker ps | grep -q ${NGINX_CONTAINER_NAME}; then
                            echo "‚úÖ Nginx container is running"
                            echo "üìã Nginx container logs:"
                            docker logs --tail 20 ${NGINX_CONTAINER_NAME} || true
                        else
                            echo "‚ùå Nginx container failed to start"
                            docker logs ${NGINX_CONTAINER_NAME} || true
                            exit 1
                        fi
                    """
                    
                    // Ki·ªÉm tra port 80 c√≥ listen kh√¥ng
                    sh """
                        echo "üîç Checking port 80..."
                        netstat -tlnp | grep :80 || ss -tlnp | grep :80 || echo "‚ö†Ô∏è  Port 80 not found in netstat"
                    """
                    
                    // Ki·ªÉm tra Nginx c√≥ th·ªÉ connect ƒë·∫øn frontend kh√¥ng
                    sh """
                        echo "üîç Testing Nginx -> Frontend connection..."
                        docker exec ${NGINX_CONTAINER_NAME} wget -q -O- http://itworks-frontend/health || echo "‚ö†Ô∏è  Nginx cannot connect to frontend"
                    """
                    
                    // Ki·ªÉm tra qua Nginx reverse proxy (HTTP) - th·ª≠ nhi·ªÅu l·∫ßn
                    sh """
                        retry_count=0
                        max_retries=5
                        while [ \$retry_count -lt \$max_retries ]; do
                            sleep 2
                            if curl -f http://localhost/health 2>/dev/null; then
                                echo "‚úÖ Health check endpoint is available"
                                exit 0
                            fi
                            retry_count=\$((retry_count + 1))
                            echo "‚è≥ Retry \$retry_count/\$max_retries..."
                        done
                        echo "‚ö†Ô∏è  Health check endpoint not available after \$max_retries retries"
                        echo "üìã Checking Nginx logs:"
                        docker logs --tail 30 ${NGINX_CONTAINER_NAME} || true
                    """
                    
                    // Ki·ªÉm tra trang ch·ªß qua Nginx (HTTP)
                    sh """
                        curl -f http://localhost/ || echo "‚ö†Ô∏è  Homepage check failed"
                    """
                    
                    // Ki·ªÉm tra HTTPS n·∫øu c√≥ SSL (d√πng bi·∫øn t·ª´ stage tr∆∞·ªõc)
                    def sslExists = env.SSL_EXISTS ?: sh(
                        script: "sudo -n test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem 2>/dev/null && echo 'exists' || echo 'not_exists'",
                        returnStdout: true
                    ).trim()
                    
                    if (sslExists == 'exists') {
                        sh """
                            echo "üîí Testing HTTPS..."
                            curl -k -f https://localhost/health || echo "‚ö†Ô∏è  HTTPS health check failed"
                        """
                    }
                }
            }
        }
        
        stage('Setup SSL Auto-Renewal') {
            steps {
                script {
                    echo 'üîÑ Setting up SSL auto-renewal...'
                    
                    // Ki·ªÉm tra SSL c√≥ t·ªìn t·∫°i kh√¥ng (d√πng bi·∫øn t·ª´ stage tr∆∞·ªõc)
                    def sslExists = env.SSL_EXISTS ?: sh(
                        script: "sudo -n test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem 2>/dev/null && echo 'exists' || echo 'not_exists'",
                        returnStdout: true
                    ).trim()
                    
                    if (sslExists == 'exists') {
                        // Ki·ªÉm tra quy·ªÅn sudo tr∆∞·ªõc
                        def hasSudo = sh(
                            script: "sudo -n true 2>&1 && echo 'yes' || echo 'no'",
                            returnStdout: true
                        ).trim()
                        
                        if (hasSudo == 'yes') {
                            // Setup cron job cho auto-renewal
                            sh """
                                # T·∫°o cron job ƒë·ªÉ renew SSL v√† restart Nginx container
                                (sudo crontab -l 2>/dev/null | grep -v "certbot renew.*${NGINX_CONTAINER_NAME}"; \\
                                 echo "0 0 * * * sudo certbot renew --quiet --deploy-hook \\"docker restart ${NGINX_CONTAINER_NAME}\\"") | sudo crontab -
                                
                                echo "‚úÖ SSL auto-renewal ƒë√£ ƒë∆∞·ª£c setup"
                            """
                        } else {
                            echo "‚ö†Ô∏è  Kh√¥ng c√≥ quy·ªÅn sudo, b·ªè qua auto-renewal setup"
                        }
                    } else {
                        echo "‚ö†Ô∏è  SSL ch∆∞a ƒë∆∞·ª£c setup, b·ªè qua auto-renewal"
                    }
                }
            }
        }
        
        stage('Cleanup') {
            steps {
                script {
                    echo 'üßπ Cleaning up old images...'
                    // X√≥a images c≈© (gi·ªØ l·∫°i 5 images g·∫ßn nh·∫•t) cho c·∫£ frontend v√† nginx
                    // Ch·ªâ x√≥a images kh√¥ng ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng
                    sh """
                        # Cleanup frontend images (skip images ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng)
                        docker images ${IMAGE_NAME} --format '{{.ID}} {{.Tag}}' | \\
                        grep -v latest | \\
                        sort -k2 -n -r | \\
                        tail -n +6 | \\
                        awk '{print \$1}' | \\
                        while read image_id; do
                            # Ki·ªÉm tra image c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng kh√¥ng
                            if ! docker ps -a --format '{{.Image}}' | grep -q "\${image_id}"; then
                                docker rmi \${image_id} 2>/dev/null || true
                            fi
                        done || true
                        
                        # Cleanup nginx images (skip images ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng)
                        docker images ${NGINX_IMAGE_NAME} --format '{{.ID}} {{.Tag}}' | \\
                        grep -v latest | \\
                        sort -k2 -n -r | \\
                        tail -n +6 | \\
                        awk '{print \$1}' | \\
                        while read image_id; do
                            # Ki·ªÉm tra image c√≥ ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng kh√¥ng
                            if ! docker ps -a --format '{{.Image}}' | grep -q "\${image_id}"; then
                                docker rmi \${image_id} 2>/dev/null || true
                            fi
                        done || true
                        
                        echo "‚úÖ Cleanup completed"
                    """
                }
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ Pipeline completed successfully!'
            // C√≥ th·ªÉ th√™m notification ·ªü ƒë√¢y (email, Slack, etc.)
        }
        failure {
            echo '‚ùå Pipeline failed!'
            script {
                // Log container logs n·∫øu fail
                sh """
                    docker logs ${CONTAINER_NAME} || true
                """
            }
        }
        always {
            echo 'üìã Pipeline finished'
            // Cleanup workspace n·∫øu c·∫ßn
            // cleanWs()
        }
    }
}

